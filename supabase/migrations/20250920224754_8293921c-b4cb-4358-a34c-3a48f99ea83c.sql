-- =========================================================
-- CALENDARIO - Extensión del CRM existente
-- =========================================================

-- 0) ENUMS calendario
DO $$ BEGIN
  CREATE TYPE public.session_type_enum AS ENUM ('S1','S2','S3');
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

DO $$ BEGIN
  CREATE TYPE public.session_status_enum AS ENUM ('scheduled','completed','cancelled','no_show');
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

-- 1) Tablas
-- Calendarios (permite futuros múltiples calendarios por workspace)
CREATE TABLE IF NOT EXISTS public.calendars (
  id            BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  workspace_id  BIGINT NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
  name          TEXT NOT NULL DEFAULT 'Principal',
  timezone      TEXT NOT NULL DEFAULT 'Europe/Madrid',
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Disponibilidad recurrente por día de semana (0=dom,6=sáb)
CREATE TABLE IF NOT EXISTS public.availability_rules (
  id            BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  workspace_id  BIGINT NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
  calendar_id   BIGINT NOT NULL REFERENCES public.calendars(id)  ON DELETE CASCADE,
  weekday       INT NOT NULL CHECK (weekday BETWEEN 0 AND 6),
  start_time    TIME NOT NULL,   -- ej 09:00
  end_time      TIME NOT NULL,   -- ej 13:00
  active        BOOLEAN NOT NULL DEFAULT true,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (calendar_id, weekday, start_time, end_time)
);

-- Excepciones de disponibilidad: aperturas/cierres en fechas específicas
CREATE TABLE IF NOT EXISTS public.availability_exceptions (
  id            BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  workspace_id  BIGINT NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
  calendar_id   BIGINT NOT NULL REFERENCES public.calendars(id)  ON DELETE CASCADE,
  date          DATE NOT NULL,
  start_time    TIME NOT NULL,
  end_time      TIME NOT NULL,
  is_open       BOOLEAN NOT NULL DEFAULT true, -- si false: bloquea
  note          TEXT,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at    TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Sesiones (citas) asociadas a leads
CREATE TABLE IF NOT EXISTS public.sessions (
  id            BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  workspace_id  BIGINT NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
  calendar_id   BIGINT NOT NULL REFERENCES public.calendars(id)  ON DELETE CASCADE,
  lead_id       BIGINT     REFERENCES public.leads(id) ON DELETE SET NULL,
  type          public.session_type_enum NOT NULL,    -- S1 / S2 / S3
  status        public.session_status_enum NOT NULL DEFAULT 'scheduled',
  starts_at     TIMESTAMPTZ NOT NULL,
  ends_at       TIMESTAMPTZ NOT NULL,
  price_eur     NUMERIC(12,2),                        -- si procede
  notes         TEXT,
  created_by    UUID NOT NULL,                        -- auth.users.id
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at    TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Recordatorios / notificaciones
CREATE TABLE IF NOT EXISTS public.session_reminders (
  id            BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  workspace_id  BIGINT NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
  session_id    BIGINT NOT NULL REFERENCES public.sessions(id) ON DELETE CASCADE,
  method        TEXT NOT NULL DEFAULT 'email', -- email/sms/push
  send_at       TIMESTAMPTZ NOT NULL,
  sent_at       TIMESTAMPTZ,
  status        TEXT,                           -- queued/sent/error
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- 2) RLS
ALTER TABLE public.calendars               ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.availability_rules      ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.availability_exceptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sessions                ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.session_reminders       ENABLE ROW LEVEL SECURITY;

-- Políticas base: miembro del workspace
DO $$ BEGIN
  CREATE POLICY cal_rw ON public.calendars FOR ALL USING (
    EXISTS (SELECT 1 FROM public.members m WHERE m.workspace_id = calendars.workspace_id AND m.user_id = auth.uid())
  ) WITH CHECK (
    EXISTS (SELECT 1 FROM public.members m WHERE m.workspace_id = calendars.workspace_id AND m.user_id = auth.uid())
  );
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

DO $$ BEGIN
  CREATE POLICY arw_rw ON public.availability_rules FOR ALL USING (
    EXISTS (SELECT 1 FROM public.members m WHERE m.workspace_id = availability_rules.workspace_id AND m.user_id = auth.uid())
  ) WITH CHECK (
    EXISTS (SELECT 1 FROM public.members m WHERE m.workspace_id = availability_rules.workspace_id AND m.user_id = auth.uid())
  );
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

DO $$ BEGIN
  CREATE POLICY aex_rw ON public.availability_exceptions FOR ALL USING (
    EXISTS (SELECT 1 FROM public.members m WHERE m.workspace_id = availability_exceptions.workspace_id AND m.user_id = auth.uid())
  ) WITH CHECK (
    EXISTS (SELECT 1 FROM public.members m WHERE m.workspace_id = availability_exceptions.workspace_id AND m.user_id = auth.uid())
  );
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

DO $$ BEGIN
  CREATE POLICY ses_select ON public.sessions FOR SELECT USING (
    EXISTS (SELECT 1 FROM public.members m WHERE m.workspace_id = sessions.workspace_id AND m.user_id = auth.uid())
  );
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

DO $$ BEGIN
  CREATE POLICY ses_write ON public.sessions FOR INSERT WITH CHECK (
    EXISTS (SELECT 1 FROM public.members m WHERE m.workspace_id = sessions.workspace_id AND m.user_id = auth.uid())
  );
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

DO $$ BEGIN
  CREATE POLICY ses_update ON public.sessions FOR UPDATE USING (
    EXISTS (SELECT 1 FROM public.members m WHERE m.workspace_id = sessions.workspace_id AND m.user_id = auth.uid())
  ) WITH CHECK (
    EXISTS (SELECT 1 FROM public.members m WHERE m.workspace_id = sessions.workspace_id AND m.user_id = auth.uid())
  );
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

DO $$ BEGIN
  CREATE POLICY srem_rw ON public.session_reminders FOR ALL USING (
    EXISTS (SELECT 1 FROM public.members m WHERE m.workspace_id = session_reminders.workspace_id AND m.user_id = auth.uid())
  ) WITH CHECK (
    EXISTS (SELECT 1 FROM public.members m WHERE m.workspace_id = session_reminders.workspace_id AND m.user_id = auth.uid())
  );
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

-- 3) Triggers
CREATE OR REPLACE FUNCTION public.set_updated_at()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN NEW.updated_at := now(); RETURN NEW; END$$;

DO $$ BEGIN
  CREATE TRIGGER set_av_rules_updated_at
  BEFORE UPDATE ON public.availability_rules
  FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

DO $$ BEGIN
  CREATE TRIGGER set_av_ex_updated_at
  BEFORE UPDATE ON public.availability_exceptions
  FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

DO $$ BEGIN
  CREATE TRIGGER set_sessions_updated_at
  BEFORE UPDATE ON public.sessions
  FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

-- 4) Índices
CREATE INDEX IF NOT EXISTS idx_sessions_range  ON public.sessions(workspace_id, starts_at, ends_at);
CREATE INDEX IF NOT EXISTS idx_sessions_lead   ON public.sessions(lead_id);
CREATE INDEX IF NOT EXISTS idx_av_rules_cw     ON public.availability_rules(calendar_id, weekday);
CREATE INDEX IF NOT EXISTS idx_av_exceptions_c ON public.availability_exceptions(calendar_id, date);

-- 5) Vistas para la UI
-- 5.1) Vista de sesiones por semana (para WeekGrid)
CREATE OR REPLACE VIEW public.view_calendar_week AS
SELECT
  s.id AS session_id,
  s.workspace_id,
  s.calendar_id,
  s.lead_id,
  l.full_name AS lead_name,
  s.type,
  s.status,
  s.starts_at,
  s.ends_at,
  s.price_eur,
  s.notes
FROM public.sessions s
LEFT JOIN public.leads l ON l.id = s.lead_id;

-- 5.2) Disponibilidad expandida (hoy/mañana) a partir de reglas + excepciones
-- Nota: esta vista simplifica y no hace "split" por solapamientos complejos.
CREATE OR REPLACE VIEW public.view_quick_availability AS
WITH base AS (
  SELECT
    cal.id AS calendar_id,
    cal.workspace_id,
    d::date AS day,
    ar.start_time, ar.end_time
  FROM public.calendars cal
  JOIN public.availability_rules ar
    ON ar.calendar_id = cal.id AND ar.active
  JOIN generate_series(now()::date, (now()::date + 1), '1 day'::interval) d
    ON EXTRACT(DOW FROM d) = ar.weekday
),
ex AS (
  SELECT calendar_id, date AS day, start_time, end_time, is_open
  FROM public.availability_exceptions
  WHERE date IN (now()::date, now()::date + 1)
),
merged AS (
  -- Regla base menos cierres + aperturas añadidas
  SELECT b.calendar_id, b.workspace_id, b.day, b.start_time, b.end_time
  FROM base b
  LEFT JOIN ex e
    ON e.calendar_id = b.calendar_id AND e.day = b.day
       AND e.is_open = false 
       AND e.start_time = b.start_time AND e.end_time = b.end_time
  WHERE e.calendar_id IS NULL
  UNION ALL
  SELECT e.calendar_id, (SELECT workspace_id FROM public.calendars c WHERE c.id=e.calendar_id),
         e.day, e.start_time, e.end_time
  FROM ex e WHERE e.is_open = true
)
SELECT * FROM merged
ORDER BY day, start_time;

-- 6) Seed (demo)
-- Reutiliza workspace y miembro de CRM
WITH ws AS (SELECT id FROM public.workspaces WHERE name='Demo Workspace' LIMIT 1)
INSERT INTO public.calendars(workspace_id, name, timezone)
SELECT id, 'Principal', 'Europe/Madrid' FROM ws
ON CONFLICT DO NOTHING;

-- Reglas: Lun–Vie 09:00–13:00 y 15:00–19:00
WITH cal AS (SELECT id, workspace_id FROM public.calendars LIMIT 1),
     wd AS (SELECT unnest(ARRAY[1,2,3,4,5]) AS weekday)
INSERT INTO public.availability_rules(workspace_id, calendar_id, weekday, start_time, end_time)
SELECT c.workspace_id, c.id, w.weekday, t.start_t, t.end_t
FROM cal c, wd w,
LATERAL (VALUES ('09:00'::time,'13:00'::time),
               ('15:00'::time,'19:00'::time)) AS t(start_t,end_t)
ON CONFLICT DO NOTHING;

-- Excepciones: hoy abierto 09-13 y 15-19 (ya cubierto por reglas), mañana igual (expresa explícito)
WITH cal AS (SELECT id, workspace_id FROM public.calendars LIMIT 1)
INSERT INTO public.availability_exceptions(workspace_id, calendar_id, date, start_time, end_time, is_open, note)
SELECT c.workspace_id, c.id, now()::date + 1, '09:00','13:00', true, 'Apertura explícita mañana'
FROM cal c
ON CONFLICT DO NOTHING;

-- Sesiones demo: (casan con tus capturas)
-- S1 (10'), S2 (20-30'), S3 (30+)
WITH
  cal AS (SELECT id, workspace_id FROM public.calendars LIMIT 1),
  p AS (SELECT '00000000-0000-0000-0000-000000000000'::uuid AS demo_user),
  ana AS (SELECT id FROM public.leads WHERE full_name='Ana García'   LIMIT 1),
  car AS (SELECT id FROM public.leads WHERE full_name='Carlos Ruiz' LIMIT 1)
INSERT INTO public.sessions(workspace_id, calendar_id, lead_id, type, status, starts_at, ends_at, price_eur, notes, created_by)
SELECT c.workspace_id, c.id, (SELECT id FROM ana), 'S1','scheduled',
       date_trunc('day', now()) + interval '1 day' + time '10:00',
       date_trunc('day', now()) + interval '1 day' + time '10:10',
       1200, 'Confirmar asistencia S1', (SELECT demo_user FROM p)
FROM cal c
UNION ALL
SELECT c.workspace_id, c.id, (SELECT id FROM car), 'S2','scheduled',
       date_trunc('day', now()) + time '12:00',
       date_trunc('day', now()) + time '12:30',
       2400, 'Enviar enlace S2', (SELECT demo_user FROM p)
FROM cal c
ON CONFLICT DO NOTHING;